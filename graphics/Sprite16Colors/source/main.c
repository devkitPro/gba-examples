// SPDX-License-Identifier: CC0-1.0
//
// Example of how to load a 16-color sprite

#include <gba_video.h>
#include <gba_sprites.h>
#include <gba_interrupt.h>
#include <gba_systemcalls.h>

#include "ball.h" // Autogenerated from ball.png

// This defines the tile index where the data of the ball is loaded in tile VRAM
#define BALL_TILES_BASE	(16)

// This is the palette index to be used for the sprite. There are 16 palettes of
// 16 colors each available.
#define BALL_PALETTE	(2)

int main(void)
{
	// Enable interrupts. This is needed for VBlankIntrWait() to work.
	irqInit();
	irqEnable(IRQ_VBLANK);

	// Set object attributes
	// ---------------------

	// Get pointer to the entry that describes the attributes of object 0. Each
	// entry is composed by fields organized in an arbitrary way.
	OBJATTR *obj = &OAM[0];

	obj->attr0 =
		// Y coordinate
		OBJ_Y(10) |
		// Disable rotoscale mode
		ATTR0_TYPE_NORMAL |
		// Use a 16-color palette
		ATTR0_COLOR_16 |
		// Object shape
		ATTR0_SQUARE;

	obj->attr1 =
		// X coordinate
		OBJ_X(20) |
		// Object size
		ATTR1_SIZE_32;

	obj->attr2 =
		// Tile index of the tiles in SPRITE_GFX memory
		OBJ_CHAR(BALL_TILES_BASE) |
		// Which palette index to use (not needed for 256-color sprites)
		ATTR2_PALETTE(BALL_PALETTE) |
		// Priority relative to other layers (sprites and backgrounds)
		ATTR2_PRIORITY(1);

	// The shape of the sprite (ATTR0_SQUARE) and the size (ATTR1_SIZE_32)
	// aren't intuitive. Check the following link for more information:
	//     https://www.coranac.com/tonc/text/regobj.htm#sec-oam-entry

	// Load the palette
	// ----------------

	// Calculate the base address of the sprite palette. There are 16 possible
	// palettes of 16 colors each. The base address where they can be found is
	// SPRITE_PALETTE. The 16 palettes could be used together as one 256 color
	// palette.
	uint16_t *spr_pal_2 = SPRITE_PALETTE + (BALL_PALETTE * 16);
	CpuSet(ballPal, spr_pal_2, COPY32 | (ballPalLen / 4));

	// Load the tiles
	// --------------

	// 4 bits (16 colors), 8x8, transform from bits to bytes
#define TILE_SIZE (4 * 8 * 8) / 8
	uint8_t *spr_tiles = (uint8_t *)SPRITE_GFX + (BALL_TILES_BASE * TILE_SIZE);
	CpuSet(ballTiles, spr_tiles, COPY32 | (ballTilesLen / 4));

	// Turn on the screen
	// ------------------

	REG_DISPCNT =
		// The mode doesn't matter here, it only affects the backgrounds. This
		// is just an arbitrary value.
		MODE_0 |
		// Turn on the rendering of sprites.
		OBJ_ON |
		// Enable 1D mapping. Check "8.2.1. The sprite mapping mode" in the
		// following link for more information:
		//     https://www.coranac.com/tonc/text/regobj.htm#sec-tiles
		OBJ_1D_MAP;

	while (1)
	{
		// Wait for the next frame
		VBlankIntrWait();
	}
}


